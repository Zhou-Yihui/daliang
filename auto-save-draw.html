<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>星门字符自动保存</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { margin: 0; background: #0b0c2a; color: #fff; font-family: Microsoft YaHei; text-align: center; }
        #canvas { background: #111; border: 1px solid #f0c000; border-radius: 6px; touch-action: none; margin: 20px auto; display: block; }
        button { margin: 10px; padding: 8px 16px; border: none; border-radius: 4px; background: #f0c000; color: #000; cursor: pointer; }
        #chars { width: 100%; text-align: left; margin-top: 20px; }
        #export { background: #007bff; color: white; }
        #export:hover { background: #0056b3; }
        .char-item { margin: 10px; padding: 10px; border: 1px solid #f0c000; border-radius: 4px; }
        .char-item img { max-width: 100px; max-height: 100px; }
    </style>
</head>
<body>
    <h2>星门字符自动保存</h2>
    <canvas id="canvas" width="300" height="300"></canvas>
    <div>
        <button onclick="clearCanvas()">清空画布</button>
        <button onclick="saveChar()">保存字符</button>
        <button id="export" onclick="exportChars()">导出所有字符</button>
    </div>
    <h3>已保存字符</h3>
    <div id="chars"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let strokes = [];
        let currentCharStrokes = [];
        let drawing = false;

        // 获取鼠标或触摸位置
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            return e.touches ? { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top } : { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        // 绘制当前笔画
        function drawCurrent() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            if (strokes.length > 0) {
                ctx.moveTo(strokes[0].x, strokes[0].y);
                for (let i = 1; i < strokes.length; i++) {
                    ctx.lineTo(strokes[i].x, strokes[i].y);
                }
                ctx.strokeStyle = '#f0c000';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // 绘制已保存的笔画
            for (const savedStroke of currentCharStrokes) {
                ctx.beginPath();
                ctx.moveTo(savedStroke[0].x, savedStroke[0].y);
                for (let i = 1; i < savedStroke.length; i++) {
                    ctx.lineTo(savedStroke[i].x, savedStroke[i].y);
                }
                ctx.strokeStyle = '#f0c000';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // 绘画事件监听
        canvas.addEventListener('mousedown', e => { drawing = true; strokes.push(getPos(e)); drawCurrent(); });
        canvas.addEventListener('mousemove', e => { if (!drawing) return; strokes.push(getPos(e)); drawCurrent(); });
        canvas.addEventListener('mouseup', () => { drawing = false; breakStroke(); });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing = true; strokes.push(getPos(e.touches[0])); drawCurrent(); });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!drawing) return; strokes.push(getPos(e.touches[0])); drawCurrent(); });
        canvas.addEventListener('touchend', () => { drawing = false; breakStroke(); });

        // 清空画布
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            currentCharStrokes = [];
        }

        // 断开笔画并保存到当前字符
        function breakStroke() {
            if (strokes.length > 0) {
                currentCharStrokes.push([...strokes]);
                strokes = [];
                drawCurrent();
            }
        }

        // 保存字符
        function saveChar() {
            if (currentCharStrokes.length === 0 && strokes.length === 0) return alert('请先绘制字符！');
            
            if (strokes.length > 0) {
                currentCharStrokes.push([...strokes]);
                strokes = [];
            }
            
            if (currentCharStrokes.length > 0) {
                const charName = 'char_' + new Date().getTime(); // 自动生成唯一名称
                const template = currentCharStrokes.map(stroke => normalize(stroke));
                localStorage.setItem(charName, JSON.stringify(template));
                updateCharsList();
                currentCharStrokes = [];
                clearCanvas();
                alert(`字符 ${charName} 已保存！`);
            }
        }

        // 归一化笔画
        function normalize(stroke) {
            const xs = stroke.map(p => p.x);
            const ys = stroke.map(p => p.y);
            const minX = Math.min(...xs);
            const minY = Math.min(...ys);
            return stroke.map(p => ({ x: p.x - minX, y: p.y - minY }));
        }

        // 更新字符列表
        function updateCharsList() {
            const charsContainer = document.getElementById('chars');
            charsContainer.innerHTML = '';
            const charKeys = Object.keys(localStorage).filter(key => key.startsWith('char_'));
            charKeys.forEach(key => {
                const charDiv = document.createElement('div');
                charDiv.className = 'char-item';
                charDiv.innerHTML = `
                    <strong>${key}</strong>
                    <button onclick="deleteChar('${key}')">删除</button>
                    <div style="margin-top: 10px;">${getCharPreview(key)}</div>
                `;
                charsContainer.appendChild(charDiv);
            });
        }

        // 删除字符
        function deleteChar(key) {
            localStorage.removeItem(key);
            updateCharsList();
            alert(`字符 ${key} 已删除！`);
        }

        // 获取字符预览
        function getCharPreview(key) {
            const template = JSON.parse(localStorage.getItem(key));
            if (!template || template.length === 0) return '无预览';
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 100;
            canvas.height = 100;
            ctx.strokeStyle = '#f0c000';
            ctx.lineWidth = 2;
            for (const stroke of template) {
                if (stroke.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(stroke[0].x, stroke[0].y);
                    for (let i = 1; i < stroke.length; i++) {
                        ctx.lineTo(stroke[i].x, stroke[i].y);
                    }
                    ctx.stroke();
                }
            }
            return canvas.toDataURL();
        }

        // 导出所有字符
        function exportChars() {
            const allChars = {};
            const charKeys = Object.keys(localStorage).filter(key => key.startsWith('char_'));
            charKeys.forEach(key => {
                allChars[key] = JSON.parse(localStorage.getItem(key));
            });
            const json = JSON.stringify(allChars, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'stargate_chars.json';
            a.click();
            URL.revokeObjectURL(url);
            alert('所有字符已导出！');
        }

        // 初始化
        updateCharsList();
    </script>
</body>
</html>
